# ðŸ§­ Two Pointer Algorithm Summary

## ðŸ“Œ Key Concept

- **Two Pointer** is a technique where you use two indices (or pointers) to traverse a data structure, usually a **sorted array** or **string**, to solve problems efficiently in **O(n)** time.
- One pointer starts at the **beginning**, the other at the **end**, and both move toward each other based on some condition.

---
## [Leetcode 28. Find the Index of the First Occurrence in a String](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/?envType=problem-list-v2&envId=two-pointers) [2025-06-02]

```c
#include <string.h>

int strStr(char* haystack, char* needle) {
    char* p = strstr(haystack, needle);

    if ( p != NULL) {
        return p - haystack;
    } 
    
    return -1;

}
```
- I could solve it with two pointer method using index i and j, but it's brute force.
- **KMP** can be a good option, but used strstr.
- The point is, memory address difference btw p and haystack is the index difference. 

## [Leetcode 88. Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/description/?envType=problem-list-v2&envId=two-pointers) [2025-06-05]

- Runtime 100% memory 60.25%, 33min, First trial 
```c
int cmp (const void* a, const void* b) {
    return *(int*)a - *(int*)b;
}

void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n) {
    
    for (int i = 0; i <nums2Size; i++) {
        nums1[m++] =nums2[i];
    }
    qsort(nums1, nums1Size, sizeof(int), cmp);

}
```
- This approach is simple,but not using two pointers apporach. Also (m+n)log(m+n).

- Runtime 100% memory 94.03%, 33min, Second trial 
```c
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n) {

    int i = m-1;
    int j = n-1;
    int k = nums1Size-1;

    while (j >=0) {
        
        if (i >=0 && nums1[i] > nums2[j]) {
            nums1[k--] = nums1[i--];
        } else {
            nums1[k--] = nums2[j--];
        }
    }

}
```
- Pointers start at the back of the arrays becuase nums1 and nums2 are already sorted.
- O(m+n) ! 


## [Leetcode 88. Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/description/?envType=problem-list-v2&envId=two-pointers) [2025-06-05]

- Runtime 100% memory 60.25%, 33min, First trial 
```c

```
- This approach is simple,but not using two pointers apporach. Also (m+n)log(m+n).

## [Leetcode 88. Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/description/?envType=problem-list-v2&envId=two-pointers) [2025-06-05]

- Runtime 100% memory 60.25%, 33min, First trial 
```c

```
- This approach is simple,but not using two pointers apporach. Also (m+n)log(m+n).

## [Leetcode 88. Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/description/?envType=problem-list-v2&envId=two-pointers) [2025-06-05]

- Runtime 100% memory 60.25%, 33min, First trial 
```c

```
- This approach is simple,but not using two pointers apporach. Also (m+n)log(m+n).

## [Leetcode 88. Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/description/?envType=problem-list-v2&envId=two-pointers) [2025-06-05]

- Runtime 100% memory 60.25%, 33min, First trial 
```c

```
- This approach is simple,but not using two pointers apporach. Also (m+n)log(m+n).


  

---



## ðŸ”§ When to Use

- The input is **sorted** (array or string)
- You're finding **pairs**, **subarrays**, or **ranges** that meet certain conditions
- You're working with **palindromes**, **duplicates**, **window sums**, etc.

---

## ðŸ“ˆ Time Complexity

- Typically **O(n)** for linear scan
- Often more efficient than brute force (**O(nÂ²)**)

---

## ðŸ§ª Common Variants

| Variant | Use Case |
|--------|----------|
| Start-End | `left = 0, right = n - 1` â†’ for sum-based problems |
| Forward-Forward | `i = 0, j = 0` â†’ for sliding window problems |
| Bidirectional | Matching from both ends (e.g., palindrome checks) |

---

