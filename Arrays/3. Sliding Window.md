# ðŸ§­ Sliding Window Algorithm Summary

## ðŸ“Œ Key Concept

- **Sliding Window** is a technique for problems involving **contiguous subarrays or substrings** in arrays/strings.
- It uses a **window of variable or fixed size** that slides across the input, avoiding redundant computation.
- Ideal for **sum, average, max/min, or frequency count** problems.

---

## [Leetcode 3318. Find X-Sum of All K-Long Subarrays I
](https://leetcode.com/problems/find-x-sum-of-all-k-long-subarrays-i/description/?envType=problem-list-v2&envId=sliding-window) [2025-06-02]

- beat 98.19%
  
```c
class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        int size = n - k + 1;
        vector<int> result(size);
        unordered_map<int, int> freq;

        // Initialize first window
        for (int i = 0; i < k; ++i) {
            freq[nums[i]]++;
        }

        for (int i = 0; i < size; ++i) {
            // Step 1: Convert freq map to vector and sort it
            vector<pair<int, int>> sorted(freq.begin(), freq.end());
            sort(sorted.begin(), sorted.end(), [](auto& a, auto& b) {
                if (a.second == b.second)
                    return a.first > b.first; // Higher value first if same frequency
                return a.second > b.second;   // Higher frequency first
            });

            // Step 2: Sum top x frequent elements
            int sum = 0;
            int count = 0;
            for (auto& [val, f] : sorted) {
                if (count++ >= x) break;
                sum += val * f;
            }
            result[i] = sum;

            // Step 3: Slide window forward
            if (i + k < n) {
                freq[nums[i]]--;
                if (freq[nums[i]] == 0) freq.erase(nums[i]);
                freq[nums[i + k]]++;
            }
        }

        return result;
    }
};

```

- separate each step
- 1. Put first window into hashmap as a form of <value, frequency>
  2. Convert map to vector, and sort it
  3. Sum top x frequent elements
  4. slide window forawd


## [Leetcode 643. Maximum Average Subarray I](https://leetcode.com/problems/maximum-average-subarray-i/description/?envType=problem-list-v2&envId=sliding-window) [2025-06-05]

- Runtime 100% memory 93.27%, 15min, First trial 
```c
double findMaxAverage(int* nums, int numsSize, int k) {
    int start = 0;
    double average = 0;
    double maxavg = 0;

    for (start; start < k; start++) {
        average = average + nums[start] / (double)k;
    }
    maxavg = average;

    int i = 0;
    for (start; start < numsSize; start++) {
        average = average + nums[start]/(double)k - nums[i++]/(double)k;
        if (average > maxavg) {
            maxavg = average;
        }
    }

    return maxavg;
}
```
- Don't forget to cast int to double.
- It doesn't need to be divided every time.
- Max avg == Max sum, so just get the max subarray sum and divide it at the end! 

## [Leetcode 88. Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/description/?envType=problem-list-v2&envId=two-pointers) [2025-06-05]

- Runtime 100% memory 60.25%, 33min, First trial 
```c

```
- This approach is simple,but not using two pointers apporach. Also (m+n)log(m+n).
## [Leetcode 88. Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/description/?envType=problem-list-v2&envId=two-pointers) [2025-06-05]

- Runtime 100% memory 60.25%, 33min, First trial 
```c

```
- This approach is simple,but not using two pointers apporach. Also (m+n)log(m+n).
## [Leetcode 88. Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/description/?envType=problem-list-v2&envId=two-pointers) [2025-06-05]

- Runtime 100% memory 60.25%, 33min, First trial 
```c

```
- This approach is simple,but not using two pointers apporach. Also (m+n)log(m+n).
## [Leetcode 88. Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/description/?envType=problem-list-v2&envId=two-pointers) [2025-06-05]

- Runtime 100% memory 60.25%, 33min, First trial 
```c

```
- This approach is simple,but not using two pointers apporach. Also (m+n)log(m+n).


---

## ðŸ”§ When to Use

- You need to find **subarrays or substrings** that satisfy certain conditions.
- The input is **sequential** and conditions involve **length, sum, frequency**, etc.
- You're working on **maximum/minimum subarray**, **distinct characters**, **k-size windows**, etc.

---

## ðŸ“ˆ Time Complexity

- Typically **O(n)** (each element is visited at most twice)
- Efficient for large input where brute force is too slow (**O(nÂ²)**)

---

## ðŸ§ª Common Variants

| Variant | Use Case |
|--------|----------|
| Fixed-size window | Exact window length (e.g., average of every k-length subarray) |
| Variable-size window | Expand/shrink until a condition is met (e.g., longest subarray under constraint) |
| Character counting window | Substring problems involving frequency (e.g., anagram check) |
