# ðŸ§­ Bit Manipulation Algorithm Summary

## ðŸ“Œ Key Concept

- Bit Manipulation involves using bitwise operations (`&, |, ^, <<, >>`) to solve problems efficiently.
- Often used in problems involving **masks, toggling, counting bits, or optimizing space**.

---

## [Leetcode 67. Add Binary]([https://leetcode.com/problems/single-number/](https://leetcode.com/problems/add-binary/description/?envType=problem-list-v2&envId=bit-manipulation)) [2025-06-02]

```c++
char* addBinary(char* a, char* b) {
    int len_a = strlen(a);
    int len_b = strlen(b);
    int max_len = (len_a > len_b ? len_a : len_b);

    char* result = (char*)malloc(max_len + 2);
    result[max_len + 1] = '\0'; 

    int i = len_a - 1;
    int j = len_b - 1;
    int k = max_len;
    int carry = 0;

    while (i >= 0 || j >= 0 || carry > 0) {
        int bit_a = (i >= 0) ? a[i--] - '0' : 0;
        int bit_b = (j >= 0) ? b[j--] - '0' : 0;

        int sum = bit_a + bit_b + carry;
        result[k--] = (sum % 2) + '0';
        carry = sum / 2;
    }

    return result + k + 1;
}

```

- Converting string to int doesn't work (overflow)
- compare char by char, and check if there's a carry.
- k is the right before of the beggining of the start.
- so we return only valid bits !

```c++
char* s = "hello";
char* t = s + 2;  // t â†’ "llo"
printf("%s\n", t);  // print: llo
```
C,C++ can access with address, but Java and Python have to use substring or slicing. 


## [Leetcode 136. Single Number](https://leetcode.com/problems/single-number/description/?envType=problem-list-v2&envId=bit-manipulation) [2025-06-05]

- Runtime 100% memory 98.18%, 14min, First trial 
```c
int singleNumber(int* nums, int numsSize) {
    
    int result = nums[0];
    for (int i = 1; i < numsSize; i++) {
        result = result ^ nums[i];
    }

    return result;
}
```
- xor is often used to find single unrepeated value!
- Associative and Commutative laws are both valid. ( +, x, ^, &, |)

## [Leetcode 190. Reverse Bits](https://leetcode.com/problems/reverse-bits/description/?envType=problem-list-v2&envId=bit-manipulation) [2025-06-05]

- Runtime 100% memory 83.93%, 6min, First trial 
```c
uint32_t reverseBits(uint32_t n) {
    uint32_t result = 0;
    uint32_t mask = 1;
    
    for (int i =0; i<32 ; i++) {
        uint32_t dummy = n & mask;
        result = result | (dummy << (31-i));
        n = n>>1;
    }
    return result;
}
```
- use just n & 1 instead of mask variable
- don't need to shift n at the end! just access with >> i each time. 

## [Leetcode 136. Single Number](https://leetcode.com/problems/single-number/description/?envType=problem-list-v2&envId=bit-manipulation) [2025-06-05]

- Runtime 100% memory 98.18%, 14min, First trial 
```c
int singleNumber(int* nums, int numsSize) {

}
```
- xor is often used to find single unrepeated value!
- Associative and Commutative laws are both valid. ( +, x, ^, &, |)

## [Leetcode 136. Single Number](https://leetcode.com/problems/single-number/description/?envType=problem-list-v2&envId=bit-manipulation) [2025-06-05]

- Runtime 100% memory 98.18%, 14min, First trial 
```c
int singleNumber(int* nums, int numsSize) {

}
```
- xor is often used to find single unrepeated value!
- Associative and Commutative laws are both valid. ( +, x, ^, &, |)
## [Leetcode 136. Single Number](https://leetcode.com/problems/single-number/description/?envType=problem-list-v2&envId=bit-manipulation) [2025-06-05]

- Runtime 100% memory 98.18%, 14min, First trial 
```c
int singleNumber(int* nums, int numsSize) {

}
```
- xor is often used to find single unrepeated value!
- Associative and Commutative laws are both valid. ( +, x, ^, &, |)
## [Leetcode 136. Single Number](https://leetcode.com/problems/single-number/description/?envType=problem-list-v2&envId=bit-manipulation) [2025-06-05]

- Runtime 100% memory 98.18%, 14min, First trial 
```c
int singleNumber(int* nums, int numsSize) {

}
```
- xor is often used to find single unrepeated value!
- Associative and Commutative laws are both valid. ( +, x, ^, &, |)



---

## ðŸ”§ When to Use

- Checking parity or bit presence
- Subset generation via bitmasks
- Space-optimized algorithms (e.g., flags, visited sets)

---

## ðŸ“ˆ Time Complexity

- Bitwise operations: **O(1)**
- Overall algorithm: **O(n)** depending on the use case
