# ðŸ§­ Linked List Algorithm Summary

## ðŸ“Œ Key Concept

- A **Linked List** is a linear data structure where each element (node) points to the next.
- Common operations include insertion, deletion, reversal, and cycle detection.
- Useful when **dynamic memory allocation** is needed or frequent insertion/deletion is required.

---

## [Leetcode 21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/description/?envType=problem-list-v2&envId=linked-list) [2025-06-03]

- Beats 100%, 26min 
```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
    struct ListNode* result;
    struct ListNode* head;
    struct ListNode* current1 = list1;
    struct ListNode* current2 = list2;

    if (list1 && !list2) {
        head = list1;
        return head;
    } else if (!list1 && list2) {
        head = list2;
        return head;
    } else if (!list1 && !list2) {
        return NULL;
    }

    if(current1->val <= current2->val) {
        head = current1;
        result = current1;
        current1 = current1->next;
    } else {
        head = current2;
        result = current2;
        current2 = current2->next;
    }

    while (current1 && current2) {
        if(current1->val <= current2->val) {
            result->next = current1;
            current1 = current1->next;
        } else {
            result->next = current2;
            current2 = current2->next;
        }
        result = result->next;
    }
    if (current1) {
        result->next = current1;
    } else if (current2) {
        result->next = current2;
    }
    return head;

}
```

- Overall good, but variable name could be simple (p1,p2)

---

## ðŸ”§ When to Use

- When frequent insertions/deletions are needed (especially at head/tail).
- When data size is unknown ahead of time.
- For problems involving sequence manipulation without array constraints.

---

## ðŸ“ˆ Time Complexity

- Traversal: **O(n)**
- Insertion/Deletion at head: **O(1)**
- Search: **O(n)** (no random access)
