# ðŸ§­ Queue Algorithm Summary

## ðŸ“Œ Key Concept

- A **Queue** is a FIFO (First In, First Out) data structure.
- Supports `enqueue`, `dequeue`, and `peek` operations.
- Useful for **BFS traversal**, **task scheduling**, and **sliding window problems**.

---

## [Leetcode 622. Design Circular Queue](https://leetcode.com/problems/design-circular-queue/description/?envType=problem-list-v2&envId=queue) [2025-06-03]

- Runtime beats 39.71% memory 52.39%, 39min, First trial
```c
typedef struct {
    int* queue;
    int head;
    int tail;
    int size;
    int capacity;

} MyCircularQueue;


MyCircularQueue* myCircularQueueCreate(int k) {
    MyCircularQueue* Myqueue = malloc(sizeof(MyCircularQueue));

    int* array = (int*)malloc(sizeof(int)*k);
    Myqueue->queue = array;
    Myqueue->head = 0;
    Myqueue->tail = 0;
    Myqueue->size = 0;
    Myqueue->capacity = k;


    return Myqueue;
}

bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) {
    int head = obj->head;
    int tail = obj->tail;
    int size = obj->size;
    int capacity = obj->capacity;
    int* queue = obj->queue;

    if (size == capacity) {
        return false; 
    }
    
    queue[tail] = value;

    if (tail+1 == capacity) {
        obj->tail = 0;
    } else {
        obj->tail = tail + 1; 
    }

    obj->size = size + 1;
    return true;
}

bool myCircularQueueDeQueue(MyCircularQueue* obj) {
    int head = obj->head;
    int tail = obj->tail;
    int size = obj->size;
    int capacity = obj->capacity;
    int* queue = obj->queue;

    if (size == 0) {
        return false; 
    }
    
    int value = queue[head];

    if (head+1 == capacity) {
        obj->head = 0;
    } else {
        obj->head = head + 1; 
    }

    obj->size = size - 1;
    return true;
}

int myCircularQueueFront(MyCircularQueue* obj) {
    int head = obj->head;
    int tail = obj->tail;
    int size = obj->size;
    int capacity = obj->capacity;
    int* queue = obj->queue;
    
    if(size == 0) {
        return -1;
    }
    return queue[head];
}

int myCircularQueueRear(MyCircularQueue* obj) {
    int head = obj->head;
    int tail = obj->tail;
    int size = obj->size;
    int capacity = obj->capacity;
    int* queue = obj->queue;

    if (size == 0) {
        return -1;
    } else if (tail == 0) {
        return queue[capacity-1];
    }

    return queue[tail-1];
}

bool myCircularQueueIsEmpty(MyCircularQueue* obj) {
    int head = obj->head;
    int tail = obj->tail;
    int size = obj->size;
    int capacity = obj->capacity;
    int* queue = obj->queue;

    return size == 0;
}

bool myCircularQueueIsFull(MyCircularQueue* obj) {
    int head = obj->head;
    int tail = obj->tail;
    int size = obj->size;
    int capacity = obj->capacity;
    int* queue = obj->queue;

    return size == capacity;
}

void myCircularQueueFree(MyCircularQueue* obj) {
    free(obj->queue);
    free(obj);
}

```
- No need to save the value in local variable. Using obj->size directly can save memory + better readability.
- Mod can reduce code lines.
```c
if (tail + 1 == capacity)
    obj->tail = 0;
else
    obj->tail = tail + 1;
```
To 
```c
obj->tail = (obj->tail + 1) % obj->capacity;
obj->head = (obj->head + 1) % obj->capacity;

```

## [Leetcode 83. Remove Duplicates from Sorted List](https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/?envType=problem-list-v2&envId=linked-list) [2025-06-03]

- Runtime 100% memory 72%, 13min, First trial 
```c

```
- while(1) is not recommended.

## [Leetcode 83. Remove Duplicates from Sorted List](https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/?envType=problem-list-v2&envId=linked-list) [2025-06-03]

- Runtime 100% memory 72%, 13min, First trial 
```c

```
- while(1) is not recommended.



---

## ðŸ”§ When to Use

- Level-order traversal (BFS)
- Rate limiting or fixed-size window tracking
- Real-time event processing

---

## ðŸ“ˆ Time Complexity

- Enqueue/Dequeue: **O(1)**
- BFS traversal: **O(n)**
